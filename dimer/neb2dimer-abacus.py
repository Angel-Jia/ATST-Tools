import numpy as np
import os

from ase.io import read, write, Trajectory
from ase import Atoms
from ase.optimize import BFGS, FIRE, QuasiNewton
from ase.constraints import FixAtoms
from ase.visualize import view
from ase.mep.neb import NEBTools, NEB, DyNEB
# from ase.mep.autoneb import AutoNEB
# from ase.mep.dimer import DimerControl, MinModeAtoms, MinModeTranslate

from ase.calculators.abacus import Abacus, AbacusProfile
from abacus_dimer import AbacusDimer

n_max = 8
neb_fmax = 0.80  # neb should be rough
dimer_fmax = 0.05 # dimer use neb guess
climb = True
scale_fmax = 1.0 # use dyneb to reduce message far from TS
mpi = 16
omp = 4
neb_algorism = "improvedtangent"
init_stru = "../IS/STRU"
final_stru = "../FS/STRU"
neb_traj = "neb_images.traj"
dimer_traj = "dimer.traj"


# setting for calculator
abacus = "abacus"
lib_dir = "/lustre/home/2201110432/example/abacus"
#lib_dir = ""
pseudo_dir = f"{lib_dir}/PP"
basis_dir = f"{lib_dir}/ORB"
pp = {
        'H':'H_ONCV_PBE-1.0.upf',
        'C':'C_ONCV_PBE-1.0.upf',
        'O':'O_ONCV_PBE-1.0.upf',
        'Fe': 'Fe_ONCV_PBE-1.0.upf'
      }
basis = {
        'H':'H_gga_6au_100Ry_2s1p.orb',
        'C':'C_gga_7au_100Ry_2s2p1d.orb',
        'O':'O_gga_7au_100Ry_2s2p1d.orb',
        'Fe':'Fe_gga_8au_100Ry_4s2p2d1f.orb',
        }

kpts = [3, 1, 2]

parameters = {
    'calculation': 'scf',
    'nspin': 2,
    'xc': 'pbe',
    'ecutwfc': 100,
    'ks_solver': 'genelpa',
    'symmetry': 1,
    'symmetry_autoclose': 1,
    'vdw_method': 'none',
    'smearing_method': 'mp',
    'smearing_sigma': 0.002,
    'basis_type': 'lcao',
    'mixing_type': 'broyden',
    'mixing_beta': 0.4,
    'mixing_gg0': 1.0,
    'mixing_ndim': 20,
    'scf_thr': 1e-7,
    'scf_nmax': 300,
    'kpts': kpts,
    'pp': pp,
    'basis': basis,
    'pseudo_dir': pseudo_dir,
    'basis_dir': basis_dir,
    'cal_force': 1,
    'cal_stress': 1,
    'init_wfc': 'atomic',
    'init_charge': 'atomic',
    'out_stru': 1,
    'out_chg': 0,
    'out_bandgap': 1,
    'out_mul': 1,
    'out_wfc_lcao': 0,
    'efield_flag': 1,
    'dip_cor_flag': 1,
    'efield_dir': 1,
}

def abacus_calc(directory="OUT", abacus='abacus', parameters={}, mpi=1, omp=1):
    """Set Abacus calculators"""
    os.environ['OMP_NUM_THREADS'] = f'{omp}'
    profile = AbacusProfile(
        argv=['mpirun', '-np', f'{mpi}', abacus])
    # add parallel setting 20230926
    out_directory = directory
    calc = Abacus(profile=profile, directory=out_directory,
                    **parameters)
    return calc

# init and final stru
atom_init = read(init_stru)
atom_final = read(final_stru)

# just use this structure
atom_init.calc = abacus_calc(directory='OPT', abacus='abacus', parameters=parameters ,mpi=mpi, omp=omp)
atom_final.calc = abacus_calc(directory='OPT', abacus='abacus', parameters=parameters ,mpi=mpi, omp=omp)
# single opt
init_relax = BFGS(atom_init)
final_relax = BFGS(atom_final)
init_relax.run(fmax=0.05)
final_relax.run(fmax=0.05)
write("init_opted.traj", atom_init, format="traj")
write("final_opted.traj", atom_final, format="traj")

# run neb and dimer 
# function setting


# run neb
images = [atom_init]
for i in range(n_max):
    image = atom_init.copy()
    image.set_calculator(abacus_calc(directory='NEB', abacus='abacus', parameters=parameters ,mpi=mpi, omp=omp))
    images.append(image)
images.append(atom_final)
neb = DyNEB(images, 
            climb=climb, dynamic_relaxation=True, fmax=neb_fmax,
            method=neb_algorism, parallel=False, scale_fmax=scale_fmax)
neb.interpolate(method="idpp")

traj = Trajectory(neb_traj, 'w', neb)
opt = FIRE(neb, trajectory=traj)
opt.run(neb_fmax)

# neb displacement to dimer
n_images = NEBTools(images)._guess_nimages()
neb_raw_barrier = max([image.get_potential_energy() for image in images])
fmax = NEBTools(images).get_fmax()
barrier = NEBTools(images).get_barrier()[0]
TS_info = [(ind, image) 
            for ind, image in enumerate(images) 
            if image.get_potential_energy() == neb_raw_barrier][0]
print(f"=== Locate TS in {TS_info[0]} of 0-{n_images-1} images  ===")
print(f"=== NEB Raw Barrier: {neb_raw_barrier:.4f} (eV) ===")
print(f"=== NEB Fmax: {fmax:.4f} (eV/A) ===")
print(f"=== Now Turn to Dimer with NEB Information ===")

# para for neb2dimer
step_before_TS = 1
step_after_TS = 1
norm_vector = 0.01
#out_vec = 'displacement_vector.npy',

ind_before_TS = TS_info[0] - step_before_TS
ind_after_TS = TS_info[0] + step_after_TS
img_before = images[ind_before_TS]
img_after = images[ind_after_TS]
image_vector = (img_before.positions - img_after.positions)
modulo_norm = np.linalg.norm(image_vector) / norm_vector
displacement_vector = image_vector / modulo_norm
print(f"=== Displacement vector generated by {ind_before_TS} and {ind_after_TS} images of NEB chain ===")
print(f"=== Which is normalized to {norm_vector} length ! ===")
#np.save(out_vec,displacement_vector)

# dimer part
dimer_init = TS_info[1].copy()
init_eigenmode_method = "displacement"
dimer = AbacusDimer(dimer_init, 
                    parameters=parameters, 
                    mpi=mpi, omp=omp, 
                    traj_file=dimer_traj,
                    init_eigenmode_method=init_eigenmode_method,
                    displacement_vector=displacement_vector)
dimer.run(fmax=dimer_fmax)